# 单元测试

反射的阶段

每一行都要手敲

![截屏2024-10-09 下午5.07.24](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午5.07.24.png)

![截屏2024-10-09 下午5.08.04](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午5.08.04.png)

junit Nunit

Dapper NHibate Mybatis  Mybatis.Net/ Mybatis-plus

微服务的项目 .net很麻烦

Mono框架 



![截屏2024-10-09 下午5.18.05](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午5.18.05.png)

添加nuget包管理器

创建测试类

```C#
Nunit
[Test]
void ddd()
{
  Console.WriteLine("a");
}
```

Mytest.cs

```
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace demo01Nunit
{
    internal class MyTest //右击，运行测试
    {
        [Test] //特性标签 [特性名称]
        //相当于java里的注解
        public void Test1()
        {
            Console.WriteLine("a");
        }
        [Test]
        public void Test2()
        {
          Console.WriteLine("b");
        }
    }
}
```

![截屏2024-10-09 下午5.45.17](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午5.45.17.png)





打开测试资源管理器，--点击测试- 测试资源管理器-右击



```
Program.cs
Nuget 单元测试
[TestFixture]


```

![截屏2024-10-09 下午6.18.59](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午6.19.19.png)



```
internal class Mytest
{
  [Setup]
  public void Init()
  {
     Console.WriteLine("连接数据库成功")
  }
  [Test]
  public void Test1()
  {
     Console.WriteLine(“”);
  }
}
```



//如果子类测试方法继承了父类的Test，那么自动继承父类的setUp

### OneTimeSetup

//只执行一次



### 断言 单元测试

断言, 是一种在程序中的一阶

![截屏2024-10-09 下午6.32.47](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午6.32.47.png)



断言 主要是测试你的预期结果和他的结果是否相同



demo断言

设置为启动项

启动项

添加新建类



```C#
//Assert the function
public void Test5()
{
  Assert.Throws<ArgumentException>(() => {
    ContainsB("1");
  });
}

public void ContainsB(string s){
  if(s == null)
  {
    throw new Exception("s的值为null");
  }
  if(s=="1")
  {
    throw new ArgumentException("s的值为1");
  }else{
    Console.WriteLine("a");
  }
}
```

Assert.IsEmpty

```
[Test]
public void Test6()
{
    string a = '';
    a = "1";
    Assert.IsEmpty(a);
}


///Assert.Positive
[Test]
public void Test8()
{
    int a = -1;
    a = 10;
    Assert.Positive(d);
}

public void Test10()
{
   int a = 10;
   Assert.Zero(a);
}

[Test]
public void Test15()
{
   person p = new person();
   student s = new student();
   Assert.AreSame(p, s);
}
```



# IO流



```
string path="E:\\"
string path=""

path.LastIndexOf("\\");
path = path.SubString(index + 1);
Console.WriteLine(path);

//Path的使用
//1.获取文件名
Path.GetFileName(path);
Console.WriteLine(path);
//o获取文件名但是不需要扩展名
path = Path.GetFileNameWithOutExtension(path);
//3.获取扩展名
path = Path.GetExtension(path);

path = Path.GetDirectoryName(path);

5.
path = Path.GetFullPath(path);

path = Path.Combine(@"E:\A", @"b.txt");
Console.WriteLine(path);
```



### File类 操作文件



![截屏2024-10-09 下午10.32.37](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-09 下午10.32.37.png)



### File类的基本操作

创建文件

```
Console.WriteLine("请输入文件名");
string fileName = Conosole.ReadLine();
string path = @"E:\c"
File.Create()
```





多线程

```C#
public partial class Form1 : Form
{
    public Form1()
    {
       InitializeComponent();
       CheckForIllegalCrossThreadCalls = false; //取消跨线程访问的检查
    }
    public void clickDel()
    {
       for(int i = 0; i < 100000; i++)
       {
          textBox.Text = i.ToString();
       }
    }
    private void button2_Click(object sender, EventArgs e)
    {
        Thread th = new Thread(clickDel);
        Thread th1 = new Thread(() => 
        th.Start();
        
    }
}
```





![截屏2024-10-10 下午8.34.47](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午8.34.47.png)

```
public void clickDel()
{
   for(int i = 0; i < 100000; i++)
   {
       textBox1.invoke(() => 
       {
           textBox1.Text = i.ToString();
       })
   }
}
```

线程是由cpu调度的，cpu的调度权还给了线程1，这个时候呢，运行效率就很慢

有可能在同一时间，线程的控制权被cpu拿走，就造成了线程的阻塞 

cpu把控制权还给了线程2，唤醒状态

单线程的缺点，如果任务没有执行完毕 就会一直堵塞当前的ui线程（等待）

//多线程是拿成本换时间（不能但是你创建堆线程所带来的成本），因为我们cpu在大部分情况下是处于闲置状态，但是不能一次性创建太多的线程

//单线程是拿时间换成本

## 前后台线程

demo45前后台线程

```C#
public partial class Form1: Form
{
    public Form1()
    {
       InitializeComponent();
    }
    public void clickDel()
    {
        for(int i = 0; i < int.MaxValue; i++)
        {
            if(i == int.MaxValue)
            {
                MessageBos.Show(i.ToString());
            }
        
        }
    }
    
    private void button2_Click(object sender, EventArgs e)
    {
      //1.创建一个线程
       Thread thread = new Thread(clickDel);
      //只要所有前台的项目都退出，后台线程自动结束，不管任务是否执行完成
       thread.IsBackground = true; //设置为后台线程
       thread.Start();'
    }
    private void button3_Click(object sender, EventArgs e)
    {
       
    }
}
```







![截屏2024-10-10 下午9.06.44](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午9.06.44.png)





```C#
internal class Program
{
    static void Main(string[] args)
    {
       int a = 10;
       Thread thread2 = new Thread(new ParameterizedThreadStart(x => 
       {
           Console.WriteLine(x);
       }));
       Thread thread1 = new Thread(new ParameterizedThreadStart(x => 
       {
           person xx = x as person;
           thread2.Start(xx.aa + xx.bb);
       }))
       person p = new person(10, 20);
       thread1.Start(p);
    }
    record person(int aa, int bb);
}
```



多线程 并发执行的

线程1 线程2 线程3![截屏2024-10-10 下午9.39.37](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午9.39.37.png)

//在某个时间段，线程的执行权被cpu拿走了

//线程的执行权是取决于cpu

<img src="/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午9.47.38.png" alt="截屏2024-10-10 下午9.47.38" style="zoom:50%;" />





解决锁，线程锁： 需要我们提供锁对象 这个锁对象 又要哭

//然后多个线程同时竞争一个资源，那他们需要用同一个锁对象

这个锁对象，不能发送变化 不管他的值，还是饮用都不能发生变化

```C#
private static readonly object o = new object();

public static void NumCount()
{
  for (int i = 0; i < 2000; i++)
  {
     lock(o) {
        int a = number;
        a++;
        //Thread.CurrentThread.Name获取线程名称
        Console.WriteLine($"线程={Thread.CurrentThread.Name}, number={number}, a={a}");
        number = a;
        Console.WriteLine("--------");
     }
  }
}
```

![截屏2024-10-10 下午9.59.34](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午9.59.34.png)

<img src="/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午10.08.18.png" alt="截屏2024-10-10 下午10.08.18" style="zoom:50%;" />





底层

```C#
object _lockObj = x;
bool _lockWasTaken = false;
try{
  System.Threading.Monitor.Enter(__lockObj, ref __lockWasTaken)'
  //Your code'
}
finally
{
   if(__lockWasTaken) System.Threading.Monitor.Exit(__lockObj);
}


using(){
  
}
try{
  
}
```

![截屏2024-10-10 下午10.29.11](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午10.31.07.png)



![截屏2024-10-10 下午10.32.56](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午10.32.56.png)



![截屏2024-10-10 下午10.33.57](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-10 下午10.33.57.png)



```
public class Producer
{
//1.生产者只在仓库未满时进行生产苹果手机并放入队列，仓库满时生产者进程被阻塞
//2.消费者只在仓库非空时进行消费，仓库为空的时候消费者进程被阻塞
//3.当消费者发现仓库为空的时候通知生产者
//4.当生产者发现仓库满时通知消费者
    public void Product()
    {
       int a = 0;
       while(true)
       {
           Monitor.Enter(Block.o);
           {
              Block.queueProduct.Enqueue(a++); //入队列
              Thread.Sleep(1000); //Sleep线程等待 单位 毫秒为单位
              Console.WriteLine($"当前生产了{a}个手机");
              if(Block.queueProduct.Count >= 10)
              {
                 a = 1;
                 Monitor.Pulse(Block.o); //通知消费者 我要停止了 进入堵塞状态
                 Monitor.Wait(Block.o);
              }
           }
           Monitor.Exit(Block.o);
       }
    }
}
```



```C#
namespace demo100Monitor
{
    public class Block
    {
        public static readonly object o = new object();
        public static Queue<int> queueProduct = new Queue<int>();
    }
}
```



```C#
namespace demo100Monitor
{
    public class Consumer
    {
      pubic void Consume()
      {
        
         while(true)
         {
           
            Monitor.Enter(Block.o)
            {
                 if(Block.queueProduct.Count ==0)
                {
                    Monitor.Pulse(Block.o); //通知生产者可以开始执行了
                    Monitor.Wait(Block.o);  //释放资源

                }
                var i = Block.queueProduct.Dequeue(); //消费
                Console.WriteLine($"消费了{i}");
                Thread.Sleep(1000);
            }
           Monitor.Exit(Block.o);
         }
      }
    }
}
```



Program.cs

```C#
namespace demo100Monitor
{
    internal class Program
    {
       static void Main(string[] args)
       {
           Producer producer = new Producer();
           Consumer consumer = new Consumer();
         
           Thread consumerThread = new Thread(consumer.Consume);
           consumerThread.Name = "消费者";
           consumerThread.Start();
         
           Thread.Sleep(1000);
         
           Thread productThread = new Thread(producer.Product());
           productThread.Name = "生产者";
           productThread.Start();
         

       }
    }
}
```



![截屏2024-10-11 上午12.07.09](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-11 上午12.07.09.png)

消息队列

```C#
namespace demo101Semaphore 信号量
{
  internal class Program
  {
    static void Main(string[] args)
    {
       Semaphore semaphore = new Semaphore(
         5, //初始值 现在可用的资源（厕所有5个位置）
         5  
       ); //允许最大的并发量（允许五个人上厕所）
       for (int i = 0; i < 10; i++)
       { 

         Thread th = new Thread(() => {
            semaphore.WaitOne(); //占用一个信号量 数量减去一
            Console.WriteLine($"{Thread.CurrentThread.Name}进来上厕所");
            Thread.Sleep(3000);
            Console.WriteLine($"{Thread.CurrentThread.Name}粗来上厕所");
            semaphore.Release();//释放信号量，信号灯数量+1  
         });
         th.Name=$"{i}人";
         th.Start();
         //th.Join();
       }
      //semaphore.Dispose();
  }
}
```



```C#
namespace demo102ManualResetEvent
{
   internal class Program
   {
       ManualResetEvent manualResetEvent = new ManualResetEvent(false);
       Thread thread = new Thread(() => {
           Console.WriteLine("线程1是红灯，停止，等待绿灯信号");
           //当前线程是红灯，不需要往下执行 等待绿灯信号
           manualResetEvent.WaitOne();
         //manualResetEvent.Set(); 只要set一次，也就变成了绿灯，后面默认都是绿灯
           Console.WriteLine("绿灯，可用线程1可以通过了");
       });
      //模拟触发某个条件 当线程触发后 我们让线程重新执行
       Thread.Sleep(3000);
     //变成了绿灯
      manualResetEvent.Set();
     //模拟触发了某个条件，重新变回了红灯
      Thread.Sleep(3000);
     //变回红灯
      manualResetEvent.Reset();
      Console.WriteLine("我是主线程"); //阻塞子线程
      thread.Start();
   }
}
```



# 异步编程

![截屏2024-10-11 下午10.14.28](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-11 下午10.14.28.png)

![截屏2024-10-11 下午10.14.43](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-11 下午10.14.43.png)



![截屏2024-10-11 下午10.19.13](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-11 下午10.19.13.png)

![截屏2024-10-11 下午10.24.03](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-11 下午10.24.03.png)

![截屏2024-10-11 下午10.26.58](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-11 下午10.26.58.png)



