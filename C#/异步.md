## 异步编程

多线程实现异步

单线程：一个任务从头到位由一个线程完成，在一个任务完成之前，不接受第二个任务

多线程：将一个任务拆分成不同的阶段，并交给不同的线程处理



```C#
namespace demo111多线程同步
{
  internal class Program
  {
     static void Main(string[] args)
     {
         Console.WriteLine("欢迎光临，请问需要吃什么")；
         Person p = new Person();
         p.Food = Console.ReadLine();
         Console.WriteLine($"好的{p.Name}先生，请移动到配餐区");
         Thread th = new Thread(() =>{
            Console.WriteLine($"{p.Name}先生，你点的{p.Food}正在准备中，请稍后");
            Thread.Sleep(3000);
         });
       //执行顺序不一样
       //不是立刻开始线程执行的演示，而是给线程做一个标记，我已经ok了，随时可以被cpu执行
         th.Start();
        //1.让用户去做其他事情
        //2.当配餐完成时候 回来取餐
         Walk();
         WC();
         FindSeat();
         while(true)
         {
            if(th.ThreadState == ThreadState.Stopped)
            {
              Console.WriteLine($"{p.Name},您点的{p.Food}已经配餐完成");
              break;
            }
         }
       static void Walk()
       {
          Console.WriteLine("我去溜达");
       }
       static void WC()
       {
          Console.WriteLine("当前尿急");
       }
       static void FindSeat()
       {
          Console.WriteLine("找座位");
       }
     }
  }
  class Person
  {
     public string Name{get; set;}
     public string Food{get; set;}
  }
}
```





### 多线程传参

```C#
public static Program
{
  static void Main(string[] args)
  {
     int i = 10;
     Thread th = new Thread((o) =>{
        Thread.Sleep(2000);
        i = (int)o;  //装箱 在内存中会开辟新空间，不推荐，因为会发生装箱
        Console.WriteLine(i);
     });
    //
     th.Start(i);
    //Thread.Sleep(1000); //睡眠一秒中，线程执行完了，可能i会是10，还没有来得及变20；可以等待子线程执行完，再去执行主线程
    //让我们的子线程去堵塞我们的主线程
     //th.Join();  //10
     i = 20;
  }
}
//20
```



### 多线程的优先级

```C#
namespace demo多线程的优先级
{
  internal class Program
  {
      static void Main(string[] args)
      {
          int numberOne = 0;
          int numberTwo = 0;
          
          Thread th1 = new Thread(() => {
             while(true)
             {
                 numberOne++;
             }
          });
          Thread th2 = new Thread(() => {
             while(true)
             {
                 numberTwo++;
             }
          });
          th1.Priority = ThreadPriority.Highest;
          th2.Priority = ThreadPriotiry.Lowest;
          //可能不在一个cpu上，是多核cpu，在单核cpu时代，设置优先级有用，多核的情况下，没有用。
          
          th1.Start();
          th2.Start();
          Console.WriteLine("numberOne=" + numberOne);
          Console.WirteLine("numberTwo=" + numberTwo);
      }
   }
}
```



### 线程的生命周期

出生到死亡的5种状态

```C#
namespace demo114
{
   internal class Program
   {
      //创建了线程对象，但是没有执行start(), new Thread();线程对象Start 出生
     //调用Start，将线程标记为可执行状态
     //正在执行状态
     //Join/Sleep暂停，只要在过程中国线程被暂停了
     //结束状态： 完成完整执行了代码
     Thread th = new Thread(() => {
       
     });
     th.IsBackground = true; //只要所有的前台线程结束，我就自动结束
     th.Start();
     //线程中针对生命周期设置了一些相关的概念
     //Aborted: 结束线程（非正常结束)线程，线程不能再运行了
     //Interrupt() 打断线程的执行，后续还可以继续执行
     //AbortRequested:请求结束线程
     //BackGround时候是后台线程
     //Running正在执行的状态
     //Stopped线程结束的状态
     //StopRequested：请求线程结束
     //Suspended：线程挂起（不推荐使用）造成死锁
     //Unstarted：出生
     //WaitSleepJoin Join/Sleep调用这 暂停了线程
     Console.WriteLine(th.ThreadState == ThreadState.AbortRequested);
   }
}
```



```C#
Thread th = new Thread(()=>{
   for(int i = 0; i < 10; i++)
   {
      try{
        Console.WriteLine(i);
        Thread.Sleep(1000);
      } 
     catch(ThreadInterruptedException e){
        Console.WriteLine(e);
       
     }
     catch(ThreadAbortException e)
     {
        Console.WriteLine(e);
     }
   }
});
//只要我们的线程设置为后台线程，在线程处于正常的状态下（没有暂停或者阻塞线程） BackGround
//th.IsBackground = true; //只要所有的前台，线程结束了 我就自动结束
Console.WriteLine(th.ThreadState); //在调用线程之前 打印状态

th.Start();
Thread.Sleep(3000);
Console.WriteLine(th.ThreadState); //在调用线程之后 打印状态
//通过一个轮询，来不断判断子线程的状态 一旦暂停了 就立马打断
while(true)
{
   if(th.ThreadState == ThreadState.WaitSleepJoin)
   {
     //打断中止我们的线程，后续还可以正常执行
      th.Abort(); //非正常结束，打断了就不能开始了
      break;
   }
   Console.WriteLine(th.ThreadState);
  
}
```



### 多线程同步



CPU视角：

并发： 一段时间内，同时做多件事情， CPU来回切换任务

并行：同一个时刻，做多件事儿，多个cpu处理多件事情



编程视角：

同步： 等待前一个任务结束后，再执行下一个任务，无并发或者并行概念

异步： 多个任务，同时执行，并发 & 并行

![截屏2024-10-12 上午10.42.28](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-12 上午10.42.28.png)





多线程同步： 当有一个线程对内存某一块地址操作的时候，不允许其他线程对这个内存地址进行操作，直到该线程操作完成

应用：在使用多线程进行开发的过程中，一些敏感重要的数据不允许多个线程同时访问，此时就需要多线程同步技术，保证数据在任何时刻，最多有一个线程访问。



```C#
namespace demo115
{
   internal class Program
   {
     //可见性和有序性
     //volatile cpu就不去操作寄存器了，直接去操作内存了，但如果第一个线程只是+1了，但是还没有把值存入内存的话，那第二个线程拿到的时候还是之前的值，也不是最新的值，但是保证了直接存入内存，但是原子性无法保证，所以要怎么保证原子性呢？
      
       private static volatile int Count = 0;
       private static object o = new object();
       static void Main(string[] args)
       {
         
          Thread th = new Thread(()=>{
             for(int i = 0; i< 10000; i++)
             {
               //为了保证原子性
               //加了锁之后就是 线程1 进来然后更改Count的数字，这个过程是锁住内存的，等线程1执行完了，再把锁的钥匙给了线程2，这样线程2才能执行，线程2执行的时候🔒又上了，所以线程1只能在门口排队
               Monitor.Enter(o);
               Count++;
               Monitor.Exit(o);
               //去内存器中读取Count的值
               //在寄存器中给COunt的值+1
               //把改变后的值存入内存
               
               //Il 中间代码 ---》 二进制 有序性
             }
          });
          Thread t2 = new Thread(() => {
             for(int i = 0; i < 10000; i++)
             {
               lock(o)
               {
                   Count++;
               }
             }
          });
          t1.Start();
          t2.Start();
          Thread.Sleep(4000);
          Console.WriteLine(Count);
       }
   }
}
```

//当前在内存里有个值，count = 0

![截屏2024-10-12 上午10.53.00](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-12 上午10.53.00.png)

cpu内存器



1.线程1，去内存中读取数据，会读到Count = 0，并把Count = 0 保存在内存里面

2.在cpu寄存器，执行count++，执行完成之后

3.将改变后的值重新写入到内存中



### 并发编程的三大特征

可见性： 当一个线程访问一个变量并且修改的时候 其他线程能看到修改后的值

原子性：一次操作或者多个操作要么全部执行 要么全部不执行 不被任何值打断

有序性： 程序按照顺序去执行



### Volatile和互斥锁

volatile，在类前面加 就是告诉cpu不再去程序计步器里面 而是去操作程序内存

他只保障了可见性和有序性 但是没有保障原子性

Monitor .enter(). 进入锁 互斥锁

Monitor.end() 解开锁

lock



### Interlock和Synchronised



```C#
namespace demo115
{
   internal class Program
   {
     //可见性和有序性
     //volatile cpu就不去操作寄存器了，直接去操作内存了，但如果第一个线程只是+1了，但是还没有把值存入内存的话，那第二个线程拿到的时候还是之前的值，也不是最新的值，但是保证了直接存入内存，但是原子性无法保证，所以要怎么保证原子性呢？
      
       private static int Count = 0;
       private static object o = new object();
       static void Main(string[] args)
       {
         
          Thread th = new Thread(()=>{
             for(int i = 0; i< 10000; i++)
             {
                Interlocked.Increment(ref Count);
               //interlocked和锁是一个原理，里面要传入哪个要原子性的数据，ref变量,这个只能锁一个变量
               //但如果我们想锁一个方法的话，需要怎么办捏
               //锁方法 
               //加注解[mtehodimploptions.synchronized]
             }
          });
          Thread t2 = new Thread(() => {
             for(int i = 0; i < 10000; i++)
             {
               lock(o)
               {
                   Interlocked.Increment(ref Count);
               }
             }
          });
          t1.Start();
          t2.Start();
          Thread.Sleep(4000);
          Console.WriteLine(Count);
       }
   }
}
```





```C#
namespace demo115
{
   internal class Program
   {
     //可见性和有序性
     //volatile cpu就不去操作寄存器了，直接去操作内存了，但如果第一个线程只是+1了，但是还没有把值存入内存的话，那第二个线程拿到的时候还是之前的值，也不是最新的值，但是保证了直接存入内存，但是原子性无法保证，所以要怎么保证原子性呢？
      
       private static volative int Count = 0;
       static void Main(string[] args)
       {
          new Thread(T1).Start();
          new Thread(T2).Start();
          Thread.Sleep(4000);
          Console.WriteLine(Count); //10000
       }
     //只要打上这个注解，就被锁住啦
       [MethodImpl(MethodImplOptions.Synchronized)]
       public static void T1()
       {
         for(int i = 0; i < 10000; i++)
         {
            Count++;
         }
       }
   }
}
```





### 死锁

互相占用资源不给别人

敬业福 爱国福



死锁

互斥性： 当一个资源被线程使用的时候，别的线程不能使用 //前几章都说明了互斥性

不可抢占性： 资源请求者不可强制从资源拥有者中抢夺资源 

占有切等待性： 资源请求者在等待其他资源时候，保持原有资源的占用 

循环等待性： 线程1 等待线程2占有的资源，线程2等待线程1占有的资源





死锁的特性

```C#
//代码模拟死锁
namespace demo117死锁
{
   internal class Program
   {
       private static object o1 = new object(); //敬业福
       private static object o2 = new object(); //爱国福
       static void Main(string[] args)
       {
           //集2福
           //敬业福
           //爱国福
           //线程1 表示男生 拿到了敬业福 在等爱国福
         //四个特征，前三个基本不能动，因为我们线程同步需要保证结果的稳定性
         //我们现在能做的 就是破坏第四个条件 也就是需要我们的程序中一定不要出现 循环等待的问题
         //需要你在程序设计的初期 把循环等待的条件从根源上抹除
         //语法层面上尽量避免锁套锁的问题 出现了话 很有可能出现死锁， 改变的话 就是上面怎么锁的，下面就怎么锁
           Thread th1 = (() => {
             lock(o1)
             {
                Console.WriteLine("男生拿到了敬业福");
                Console.WriteLine("男生想要爱国福");
                Thread.Sleep(2000);
                lock(o2)
                {
                    //如果输出了这句话，代表拿到了爱国福
                   //注意这句话有没有输出
                    Console.WriteLIne("男生拿到了爱国福")
                }
             }
             //互斥性：o1被第一个线程使用，所以th2 拿不到o1了， o2被第二个资源使用了，所以th1拿不到o2了
             //不可抢占性：资源请求者不可强制从资源拥有者中抢夺资源
             //占有切等待性：资源请求者带等待其他资源时，保持原有资源的占有
             //循环等待性： 线程1等待线程2占有的资源，线程2等待线程1占有的资源
           th1.Start();
           Thread th2 = (() => {
             lock(o1)
             {
                Console.WriteLine("女生拿到了爱国福");
                Console.WriteLine("女生想要敬业福");
                Thread.Sleep(2000);
                lock(o2)
                {
                    //如果输出了这句话，代表拿到了爱国福
                   //注意这句话有没有输出
                    Console.WriteLIne("女生拿到了敬业福")
                }
             }         
           });
            th2.Start();
           //线程2 表示女性 拿到了爱国福 在等敬业福
            Console.ReadKey();
       }
   }
}
```



先执行th1，然后th1睡眠两秒，睡眠的时候，cpu把执行权给了th2，输出两句话，然后cpu把执行权还给了th1，然后就回去th1，等待o2释放，因此程序就卡死了



异步编程的演进的历史

同步方法： 调用者需要等待该方法执行完毕并返回才能继续执行，我们称这个方法是同步方法；

异步方法： 当一个方法被调用时，立即返回，并获取一个线程执行该方法内部的业务，调用者不用等待该方法执行完毕，我们成为这个方法为异步方法。异步的好处在于非阻塞（调用线程不会暂停执行去等待子线程的完成），

因此，我们可以把一些不需要立即使用结果，较为耗时的任务设为异步执行，可以提高程序的运行效率。

C# 4.0在ThreadPool的基础上推出了Task类，现在C#类库中的异步方法基本都用到了Task， C#5.0推出了async/await，让异步编程更为方便





*EAP基于事件的异步模型 基本不用啦 但要了解

优点： 使用简单

缺点： 不好处理复杂的业务逻辑，C#支持的相关模型不多



```C#
using System.Net;

namespace demo118EAP异步编程
{
   internal class Program
   {
      static void Main(string[] args)
      {
          WebClient webClient = new WebClient();
        //DownloadString 同步方法，这个事情不做完，就无法去做其他的事情
          string str = webClient.DownloadString("https://luffycity.com/actual-course/612");
          Console.WriteLine("哈哈哈");
          Console.WriteLine(str);
        
        //通过EAP来实现异步编程模型
        
        //下载前 注册一个下载结束后的事件 当事件被触发的时候 就说明我们的下载任务已经完成了
        //Async就是异步
        webClient.DownloadStringCompleted += WebClient_DownloadStringCompleted;
        webClient.DownloadStringAsync(new Uri("https://www.taobao.com"));
        Console.WriteLine("哈哈哈哈");
        Console.ReadKey();
      }
      private static void WebClient_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
      {
          Console.WriteLine(e.Result);
      }
   }
}
```







*APM基于异步模型 基本不用啦， IAsyncResult, AsyncWaitHandle,一个用来等待异步结束后的同步对象

C# 中支持的类比较多，Socket，Stream等

在TPL出现之前用的最多的模型

APM支持的类比较多



```C#
namespace demo119APM
{
   internal class Program
   {
      static void Main(string[] args)
      {
          //通过文件来读取
          string path = @"/Users/joy/Documents/GitHub/study-notes/a.txt";
          string s = null;
          ThreadPool.QueueUserWorkItem((x) => {
              using (FileStream fsRead = new FileStream(path, FileMode.Open, FileAccess.Read))
              {
                 byte[] Buffer = new byte[1024*1024*2];
                 //Read是一个同步方法 会阻塞我们线程的运行
                 //APM异步模型 一般都以Begin/***开始， Endxxx结束
                 //BeginRead: 只是准备读取数据，但是没有直接去执行
                 IAsyncResult asyncResult = fsRead.BeginRead(buffer, 0, buffer.Length, null, null);
                //不是异步的东西
                //调用waitone方法进行等待， 知道数据读取完成
                 asyncResult.AsyncWaitHandle.WaitOne();

                 s = Encoding.Default.GetString(buffer);
                 fsRead.EndRead(asyncResult);
              }
          }, null);
         Thread.Sleep(1000);//主线程睡一会儿 就能读到了
         Console.WriteLine(s);
      }
   }
}
```





TPL：基于事件的异步模型Task

多线程问题： 编写繁琐，多线程同步问题，抢占资源问题，调度问题，同步问题，死锁问题，浪费资源。。。

线程池：线程的抽象封装。操作简单、节省资源。问题：获取线程执行结果，相关的连续的异步操作，很复杂

线程池：线程的抽象封装 操作简单，节省资源

发挥多核CPU的功效，提升程序整体的运行性能，不需要编写底层复杂切逻辑复杂的多线程代码





### Task async await



Task 

类Task表示一个不返回值切通常异步执行的单个操作，Task对象是首先在.NET Framework4中引入的机遇任务的异步模型的中心组建之一，由于对象执行Task的工作通常以异步方式在线程池线程上执行，而不是在主应用程序线程上同步执行，因此可以使用status属性以及属性IsCanceledIsCompleted和IsFaulted属性来确定任务的状态。通常，Lambda表达式用于指定任务要执行的工作

对于返回值的操作，请使用Task该类



```C#
namespace demo120Task
{
   internal class Program
   {
       static void Main(string[] args)
       {
         //结论： 任务是被线程池执行的 虽然我们没有手动开启线程 但是也被我们线程池中的线程执行 我们的任务封装了线程相关的操作
          Console.WriteLine($"任务主线程, 执行的线程是{Thread.CurrentThread.ManagedThreadId}, 释放的是线程池中的线程{Thread.CurrentThread.isThreadPoolThread}");
          Task task = new Task(() => Test("线程1"));
          //2.注意。我们如果以创建对象的形式来创建任务，需要调用start方法，手动执行任务
          task.Start();
         
         //2，通过静态方法来Run之间执行线程
          Task.Run(()=>Test("线程2"));
         
         //3.通过工厂来创建任务
         //通过Factory创建任务 也不需要手动调用Start方法
          Task.Factory.StartNew(() => Test("线程3"));
         
       }
     public static void Test(string taskName)
     {
        Console.WriteLine($"任务{taskName}, 执行的线程是{Thread.CurrentThread.ManagedThreadId}, 释放的是线程池中的线程{Thread.CurrentThread.isThreadPoolThread}");
     }
   }
}

//任务主线程，执行的线程为1，释放的是线程池中的线程False
//任务线程1，执行的线程为8，释放的是线程池中的线程True
```



线程池中线程的个数 是由cpu的核数来决定的 ，任务在线程池外面排队，由cpu来调度线程进行



### task拿到任务执行后的结果

同步执行任务

```C#
namespace demo120Task
{
   internal class Program
   {
       static void Main(string[] args)
       {
         //获取任务执行后的结果
         //需要 用到Task泛型
         Task<int> task1 = new Task<int>(()=>Test("线程2"));
         //同步的调度任务执行 线程false，主线程 在主线程中同步执行
         //如果很小的代码量 可以去同步执行
         //保证结果的稳定性
         //保证运行的效率，没有必要再去让cpu调一个线程
         task1.RunSynchronously();
         //task.Start();
         //start之后,可以通过result属性，拿到任务执行后的结果
         int result = task.Result;
         Console.WriteLine(result);
         Console.WriteLien("--------");
         
         
       }
     public static int Test(string taskName)
     {
        Console.WriteLine($"任务{taskName}, 执行的线程是{Thread.CurrentThread.ManagedThreadId}, 释放的是线程池中的线程{Thread.CurrentThread.isThreadPoolThread}");
     }
   }
}

//任务主线程，执行的线程为1，释放的是线程池中的线程False
//任务线程1，执行的线程为8，释放的是线程池中的线程True
```



### 控制线程的执行顺序

```C#
namespace demo
{
   internal class Program
   {
      static void Main(string[] args)
      {
         Task task1 = new Task(() => {
            Console.WriteLine("我是task1")；
            Thread.Delay(2000); //delay异步睡眠
            Console.WriteLine("task1执行完成");
         });
        Task task2 = new Task(() => {
           Console.WriteLine("我是task2");
           Thread.Sleep(2000);
           Task.Delay(1000);
           Console.WriteLine("task2执行完成");
        });
        tast1.Start();
        //等待上一个任务执行完成，并且会堵塞主线程
        task2.Start();
        //等待括号中的所有任务执行完成，才会往下执行
        //Task.WaitAll(task1, task2);
        //需求1: 我就想task1先执行，task1执行完成，再执行task2
        //2.等待两个任务执行完成后，再执行其他代码

        Console.ReadLine("等待2个任务完成后 执行的代码");
        
        //需求3: 只要2个任务，任意一个执行结束之后就可以执行后面的代码
        //Task.WaitAny(task1, task2)
        
        //需求4: 3个页面 a---》 b----》 c---〉
        task1.ContinueWith((param)=>task2.Start());
        task2.ContinueWith((param)=> {
          Console.WriteLine("我是任务三");
        });
      }
   }
}
```





### async and await

异步编程 async和await

```C#
namespace demo123asyncAwait
{
    internal class Program
    {
        static void Main(string[] args)
        {
           SyncMethod();
           asyncMethodNoWait();
           asyncMethodWithWait();
           Console.WriteLine("主线程执行完成");
          
           Console.ReadKey();
        }
        public static void SyncMethod()
        {
            Console.WriteLine("SyncMethod开始执行");
            Thread.Sleep(5000);
            Console.WriteLine("SyncMethodh执行完成");
        }
        public static async void asyncMethodNoWait()
        {
            Console.WriteLine("asyncMethodNoWait开始执行");
          //标记了async的方法如果不写await就he
            Thread.Sleep(5000); //同步等待 不创建任务
            Console.WriteLine("asyncMethodNoWait执行完成");
        }
        public static async void asyncMethodWithWait()
        {
            Console.WriteLine("asyncMethodNoWait开始执行");
            await Task.Delay(5000); //异步等待 创建任务来实现，让子线程等待，所以先输出的是“主线程执行完成”
            Console.WriteLine("asyncMethodWithWait执行完成");
        }
      //1.异步方法 如果没有await关键字，其执行原理还是同步调用 主线程遇到耗时的操作，依然会被堵塞
      //2.异步方法再调用的时候，只有遇到await才会真正的去开始异步，而一般异步的执行原理就是一个task对象
      //await之后，主线程和异步的子线程互相不影响，各自执行直到全部完成
    }
}
```





### await底层原理

```C#
namespace demo124await注意事项
{
   internal class Program
   {
     //早起的版本中Main函数 不允许被标注async
     //但是后来的版本可用标记 async甚至返回值也可以标记为Task，但是下载依然不允许标记为Task
      static async Task Main(string[] args)
      {
         WebClient webClinet = new WebClient();
        //await 的返回结果 ：string类型
        //2.如果方法中出现了await关键字，这await关键字有一个特征：传染性
         //如果用async和await所在的函数不能用void标记
        //task标记，没有返回值，也就是不需要和其他任务进行交互
        //Task<T>: 如果有返回值，则方法中的返回值的类型 就是T的类型
        //在winform中，因为我们事件和委托的密切的关系 委托是由一个明确方法的签名，在winform中 异步方法 返回值可以写void
        
         Task<string> s = webClient.DownloadStringTaskAsync("http://www.taobao.com");
         Console.WriteLine("等待下载");
         Console.WriteLine(s);
         Console.ReadKey();
      }
      public static async Task<string> AsyncTest()
      {
        
      }
   }
}
```

如果Console.WriteLine(s) 放在前面，输出结果相反，因为被卡住了

在异步等待的过程中，要先做程序要做的事情，做完了之后再去返回结果





Thread与Task的区别（面试点）

1.Task是基于Thread的，是比较高层级的封装（她是在线程池的基础之上），Task最终还是需要thread来执行

Thread是操作系统级别的线程，而Task是一个逻辑工作单元，最终也是由线程执行。Task使得开发者不需要直接管理底层线程，而可以更加注重任务本身

```C#
// 使用Thread
Thread thread = new Thread(() => Console.WriteLine("Running in Thread"));
thread.Start();

// 使用Task
Task task = Task.Run(() => Console.WriteLine("Running in Task"));

```

2.Task默认使用后台线程执行，Thread默认使用前台线程

Task使用线程池中的线程，而线程池中的线程默认为后台线程，当所有前台线程结束后，应用程序会自动中止，不会等待后台线程。而Thread默认是前台线程，应用程序会等待所有前台线程完毕后才会结束

```C#
// 创建后台线程
Thread thread = new Thread(SomeMethod);
thread.IsBackground = true; // 显式设置为后台线程
thread.Start();
```



3.Task可以有返回值，可以通过泛型(Task<TResult>)可以返回一个值，Thread没有返回值，虽然Thread可以通过Start方法参数来进行返回值处理，但是十分不便

```C#
// Task with return value
Task<int> taskWithResult = Task.Run(() => {
    return 42;
});
int result = taskWithResult.Result; // 42

// Thread 没有直接返回值
```

4.Task可以执行后续操作，Thread不能执行后续操作

Task提供了ContineWith的方法，允许在当前任务完成后执行另外的任务，从而实现任务的链式执行。而Thread本身不支持这种任务的链式处理方式

```C#
Task task = Task.Run(() => Console.WriteLine("First Task"))
    .ContinueWith(prevTask => Console.WriteLine("Second Task"));
```

5.Task可以取消任务执行，Thread不行

**解释**：`Task` 提供了取消机制，使用 `CancellationToken` 来通知任务取消执行。`Thread` 本身没有内置的取消机制，通常只能通过共享状态变量或其他方式进行取消操作。

```C#
CancellationTokenSource cts = new CancellationTokenSource();
Task task = Task.Run(() => {
   while(!cts.Token.IsCancellationRequested) {
      //Task running
   }
}, cts.Token);
//Cancel the task
cts.Cancel();
```

6.异常传播，Thread在父方法上获取不到异常，而task可以

**解释**：`Thread` 发生异常时，除非手动捕获，否则异常不会传播到调用方，而 `Task` 的异常则会通过 `Task.Result` 或 `Task.Wait()` 抛出，可以在调用方捕获和处理。

```C#
//Thread
try{
   Thread thread = new Thread(() => throw new Exception("Thread Exception"));
   thread.Start();
   thread.Join(); //这里不会捕获到异常
} catch(Exception ex){
   Console.WriteLine("Exception caught"); //不会捕获到
}

//Task
try{
   Task task = Task.Run(() => throw new Exception("Task exception"));
   task.Wait(); //这里可以捕获异常
} catch(AggregateException ex) {
   Console.WriteLine("Exception caught" + ex.Message); //捕获到
}
```

**Task** 是更高级的抽象，提供了更丰富的功能，如返回值、链式任务、取消机制等。

**Thread** 是底层的并发工具，操作灵活但不具备高层次的特性，比如返回值、异常传播等。

**Task** 更适合现代异步编程和需要任务控制的场景，而 **Thread** 在需要直接控制线程的场景下仍然有用。