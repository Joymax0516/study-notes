## 异步编程

多线程实现异步

单线程：一个任务从头到位由一个线程完成，在一个任务完成之前，不接受第二个任务

多线程：将一个任务拆分成不同的阶段，并交给不同的线程处理



```C#
namespace demo111多线程同步
{
  internal class Program
  {
     static void Main(string[] args)
     {
         Console.WriteLine("欢迎光临，请问需要吃什么")；
         Person p = new Person();
         p.Food = Console.ReadLine();
         Console.WriteLine($"好的{p.Name}先生，请移动到配餐区");
         Thread th = new Thread(() =>{
            Console.WriteLine($"{p.Name}先生，你点的{p.Food}正在准备中，请稍后");
            Thread.Sleep(3000);
         });
       //执行顺序不一样
       //不是立刻开始线程执行的演示，而是给线程做一个标记，我已经ok了，随时可以被cpu执行
         th.Start();
        //1.让用户去做其他事情
        //2.当配餐完成时候 回来取餐
         Walk();
         WC();
         FindSeat();
         while(true)
         {
            if(th.ThreadState == ThreadState.Stopped)
            {
              Console.WriteLine($"{p.Name},您点的{p.Food}已经配餐完成");
              break;
            }
         }
       static void Walk()
       {
          Console.WriteLine("我去溜达");
       }
       static void WC()
       {
          Console.WriteLine("当前尿急");
       }
       static void FindSeat()
       {
          Console.WriteLine("找座位");
       }
     }
  }
  class Person
  {
     public string Name{get; set;}
     public string Food{get; set;}
  }
}
```





### 多线程传参

```C#
public static Program
{
  static void Main(string[] args)
  {
     int i = 10;
     Thread th = new Thread((o) =>{
        Thread.Sleep(2000);
        i = (int)o;  //装箱 在内存中会开辟新空间，不推荐，因为会发生装箱
        Console.WriteLine(i);
     });
    //
     th.Start(i);
    //Thread.Sleep(1000); //睡眠一秒中，线程执行完了，可能i会是10，还没有来得及变20；可以等待子线程执行完，再去执行主线程
    //让我们的子线程去堵塞我们的主线程
     //th.Join();  //10
     i = 20;
  }
}
//20
```



### 多线程的优先级

```C#
namespace demo多线程的优先级
{
  internal class Program
  {
      static void Main(string[] args)
      {
          int numberOne = 0;
          int numberTwo = 0;
          
          Thread th1 = new Thread(() => {
             while(true)
             {
                 numberOne++;
             }
          });
          Thread th2 = new Thread(() => {
             while(true)
             {
                 numberTwo++;
             }
          });
          th1.Priority = ThreadPriority.Highest;
          th2.Priority = ThreadPriotiry.Lowest;
          //可能不在一个cpu上，是多核cpu，在单核cpu时代，设置优先级有用，多核的情况下，没有用。
          
          th1.Start();
          th2.Start();
          Console.WriteLine("numberOne=" + numberOne);
          Console.WirteLine("numberTwo=" + numberTwo);
      }
   }
}
```



### 线程的生命周期

出生到死亡的5种状态

```C#
namespace demo114
{
   internal class Program
   {
      //创建了线程对象，但是没有执行start(), new Thread();线程对象Start 出生
     //调用Start，将线程标记为可执行状态
     //正在执行状态
     //Join/Sleep暂停，只要在过程中国线程被暂停了
     //结束状态： 完成完整执行了代码
     Thread th = new Thread(() => {
       
     });
     th.IsBackground = true; //只要所有的前台线程结束，我就自动结束
     th.Start();
     //线程中针对生命周期设置了一些相关的概念
     //Aborted: 结束线程（非正常结束)线程，线程不能再运行了
     //Interrupt() 打断线程的执行，后续还可以继续执行
     //AbortRequested:请求结束线程
     //BackGround时候是后台线程
     //Running正在执行的状态
     //Stopped线程结束的状态
     //StopRequested：请求线程结束
     //Suspended：线程挂起（不推荐使用）造成死锁
     //Unstarted：出生
     //WaitSleepJoin Join/Sleep调用这 暂停了线程
     Console.WriteLine(th.ThreadState == ThreadState.AbortRequested);
   }
}
```



```C#
Thread th = new Thread(()=>{
   for(int i = 0; i < 10; i++)
   {
      try{
        Console.WriteLine(i);
        Thread.Sleep(1000);
      } 
     catch(ThreadInterruptedException e){
        Console.WriteLine(e);
       
     }
     catch(ThreadAbortException e)
     {
        Console.WriteLine(e);
     }
   }
});
//只要我们的线程设置为后台线程，在线程处于正常的状态下（没有暂停或者阻塞线程） BackGround
//th.IsBackground = true; //只要所有的前台，线程结束了 我就自动结束
Console.WriteLine(th.ThreadState); //在调用线程之前 打印状态

th.Start();
Thread.Sleep(3000);
Console.WriteLine(th.ThreadState); //在调用线程之后 打印状态
//通过一个轮询，来不断判断子线程的状态 一旦暂停了 就立马打断
while(true)
{
   if(th.ThreadState == ThreadState.WaitSleepJoin)
   {
     //打断中止我们的线程，后续还可以正常执行
      th.Abort(); //非正常结束，打断了就不能开始了
      break;
   }
   Console.WriteLine(th.ThreadState);
  
}
```



### 多线程同步



CPU视角：

并发： 一段时间内，同时做多件事情， CPU来回切换任务

并行：同一个时刻，做多件事儿，多个cpu处理多件事情



编程视角：

同步： 等待前一个任务结束后，再执行下一个任务，无并发或者并行概念

异步： 多个任务，同时执行，并发 & 并行

![截屏2024-10-12 上午10.42.28](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-12 上午10.42.28.png)





多线程同步： 当有一个线程对内存某一块地址操作的时候，不允许其他线程对这个内存地址进行操作，直到该线程操作完成

应用：在使用多线程进行开发的过程中，一些敏感重要的数据不允许多个线程同时访问，此时就需要多线程同步技术，保证数据在任何时刻，最多有一个线程访问。



```C#
namespace demo115
{
   internal class Program
   {
     //可见性和有序性
     //volatile cpu就不去操作寄存器了，直接去操作内存了，但如果第一个线程只是+1了，但是还没有把值存入内存的话，那第二个线程拿到的时候还是之前的值，也不是最新的值，但是保证了直接存入内存，但是原子性无法保证，所以要怎么保证原子性呢？
      
       private static volatile int Count = 0;
       private static object o = new object();
       static void Main(string[] args)
       {
         
          Thread th = new Thread(()=>{
             for(int i = 0; i< 10000; i++)
             {
               //为了保证原子性
               //加了锁之后就是 线程1 进来然后更改Count的数字，这个过程是锁住内存的，等线程1执行完了，再把锁的钥匙给了线程2，这样线程2才能执行，线程2执行的时候🔒又上了，所以线程1只能在门口排队
               Monitor.Enter(o);
               Count++;
               Monitor.Exit(o);
               //去内存器中读取Count的值
               //在寄存器中给COunt的值+1
               //把改变后的值存入内存
               
               //Il 中间代码 ---》 二进制 有序性
             }
          });
          Thread t2 = new Thread(() => {
             for(int i = 0; i < 10000; i++)
             {
               lock(o)
               {
                   Count++;
               }
             }
          });
          t1.Start();
          t2.Start();
          Thread.Sleep(4000);
          Console.WriteLine(Count);
       }
   }
}
```

//当前在内存里有个值，count = 0

![截屏2024-10-12 上午10.53.00](/Users/joy/Library/Application Support/typora-user-images/截屏2024-10-12 上午10.53.00.png)

cpu内存器



1.线程1，去内存中读取数据，会读到Count = 0，并把Count = 0 保存在内存里面

2.在cpu寄存器，执行count++，执行完成之后

3.将改变后的值重新写入到内存中



### 并发编程的三大特征

可见性： 当一个线程访问一个变量并且修改的时候 其他线程能看到修改后的值

原子性：一次操作或者多个操作要么全部执行 要么全部不执行 不被任何值打断

有序性： 程序按照顺序去执行



### Volatile和互斥锁

volatile，在类前面加 就是告诉cpu不再去程序计步器里面 而是去操作程序内存

他只保障了可见性和有序性 但是没有保障原子性

Monitor .enter(). 进入锁 互斥锁

Monitor.end() 解开锁

lock



### Interlock和Synchronised



```C#
namespace demo115
{
   internal class Program
   {
     //可见性和有序性
     //volatile cpu就不去操作寄存器了，直接去操作内存了，但如果第一个线程只是+1了，但是还没有把值存入内存的话，那第二个线程拿到的时候还是之前的值，也不是最新的值，但是保证了直接存入内存，但是原子性无法保证，所以要怎么保证原子性呢？
      
       private static int Count = 0;
       private static object o = new object();
       static void Main(string[] args)
       {
         
          Thread th = new Thread(()=>{
             for(int i = 0; i< 10000; i++)
             {
                Interlocked.Increment(ref Count);
               //interlocked和锁是一个原理，里面要传入哪个要原子性的数据，ref变量,这个只能锁一个变量
               //但如果我们想锁一个方法的话，需要怎么办捏
               //锁方法 
               //加注解[mtehodimploptions.synchronized]
             }
          });
          Thread t2 = new Thread(() => {
             for(int i = 0; i < 10000; i++)
             {
               lock(o)
               {
                   Interlocked.Increment(ref Count);
               }
             }
          });
          t1.Start();
          t2.Start();
          Thread.Sleep(4000);
          Console.WriteLine(Count);
       }
   }
}
```





```C#
namespace demo115
{
   internal class Program
   {
     //可见性和有序性
     //volatile cpu就不去操作寄存器了，直接去操作内存了，但如果第一个线程只是+1了，但是还没有把值存入内存的话，那第二个线程拿到的时候还是之前的值，也不是最新的值，但是保证了直接存入内存，但是原子性无法保证，所以要怎么保证原子性呢？
      
       private static volative int Count = 0;
       static void Main(string[] args)
       {
          new Thread(T1).Start();
          new Thread(T2).Start();
          Thread.Sleep(4000);
          Console.WriteLine(Count); //10000
       }
     //只要打上这个注解，就被锁住啦
       [MethodImpl(MethodImplOptions.Synchronized)]
       public static void T1()
       {
         for(int i = 0; i < 10000; i++)
         {
            Count++;
         }
       }
   }
}
```





### 死锁

互相占用资源不给别人

敬业福 爱国福



死锁

互斥性： 当一个资源被线程使用的时候，别的线程不能使用 //前几章都说明了互斥性

不可抢占性： 资源请求者不可强制从资源拥有者中抢夺资源 

占有切等待性： 资源请求者在等待其他资源时候，保持原有资源的占用 

循环等待性： 线程1 等待线程2占有的资源，线程2等待线程1占有的资源





死锁的特性

```C#
//代码模拟死锁
namespace demo117死锁
{
   internal class Program
   {
       private static object o1 = new object(); //敬业福
       private static object o2 = new object(); //爱国福
       static void Main(string[] args)
       {
           //集2福
           //敬业福
           //爱国福
           //线程1 表示男生 拿到了敬业福 在等爱国福
         //四个特征，前三个基本不能动，因为我们线程同步需要保证结果的稳定性
         //我们现在能做的 就是破坏第四个条件 也就是需要我们的程序中一定不要出现 循环等待的问题
         //需要你在程序设计的初期 把循环等待的条件从根源上抹除
         //语法层面上尽量避免锁套锁的问题 出现了话 很有可能出现死锁， 改变的话 就是上面怎么锁的，下面就怎么锁
           Thread th1 = (() => {
             lock(o1)
             {
                Console.WriteLine("男生拿到了敬业福");
                Console.WriteLine("男生想要爱国福");
                Thread.Sleep(2000);
                lock(o2)
                {
                    //如果输出了这句话，代表拿到了爱国福
                   //注意这句话有没有输出
                    Console.WriteLIne("男生拿到了爱国福")
                }
             }
             //互斥性：o1被第一个线程使用，所以th2 拿不到o1了， o2被第二个资源使用了，所以th1拿不到o2了
             //不可抢占性：资源请求者不可强制从资源拥有者中抢夺资源
             //占有切等待性：资源请求者带等待其他资源时，保持原有资源的占有
             //循环等待性： 线程1等待线程2占有的资源，线程2等待线程1占有的资源
           th1.Start();
           Thread th2 = (() => {
             lock(o1)
             {
                Console.WriteLine("女生拿到了爱国福");
                Console.WriteLine("女生想要敬业福");
                Thread.Sleep(2000);
                lock(o2)
                {
                    //如果输出了这句话，代表拿到了爱国福
                   //注意这句话有没有输出
                    Console.WriteLIne("女生拿到了敬业福")
                }
             }         
           });
            th2.Start();
           //线程2 表示女性 拿到了爱国福 在等敬业福
            Console.ReadKey();
       }
   }
}
```



先执行th1，然后th1睡眠两秒，睡眠的时候，cpu把执行权给了th2，输出两句话，然后cpu把执行权还给了th1，然后就回去th1，等待o2释放，因此程序就卡死了



异步编程的演进的历史

同步方法： 调用者需要等待该方法执行完毕并返回才能继续执行，我们称这个方法是同步方法；

异步方法： 当一个方法被调用时，立即返回，并获取一个线程执行该方法内部的业务，调用者不用等待该方法执行完毕，我们成为这个方法为异步方法。异步的好处在于非阻塞（调用线程不会暂停执行去等待子线程的完成），

因此，我们可以把一些不需要立即使用结果，较为耗时的任务设为异步执行，可以提高程序的运行效率。

C# 4.0在ThreadPool的基础上推出了Task类，现在C#类库中的异步方法基本都用到了Task， C#5.0推出了async/await，让异步编程更为方便





*EAP基于事件的异步模型 基本不用啦 但要了解

优点： 使用简单

缺点： 不好处理复杂的业务逻辑，C#支持的相关模型不多



```C#
using System.Net;

namespace demo118EAP异步编程
{
   internal class Program
   {
      static void Main(string[] args)
      {
          WebClient webClient = new WebClient();
        //DownloadString 同步方法，这个事情不做完，就无法去做其他的事情
          string str = webClient.DownloadString("https://luffycity.com/actual-course/612");
          Console.WriteLine("哈哈哈");
          Console.WriteLine(str);
        
        //通过EAP来实现异步编程模型
        
        //下载前 注册一个下载结束后的事件 当事件被触发的时候 就说明我们的下载任务已经完成了
        //Async就是异步
        webClient.DownloadStringCompleted += WebClient_DownloadStringCompleted;
        webClient.DownloadStringAsync(new Uri("https://www.taobao.com"));
        Console.WriteLine("哈哈哈哈");
        Console.ReadKey();
      }
      private static void WebClient_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
      {
          Console.WriteLine(e.Result);
      }
   }
}
```







*APM基于事件的异步模型 基本不用啦， IAsyncResult, AsyncWaitHandle

C# 中支持的类比较多，Socket，Stream等











TPL：基于事件的异步模型















